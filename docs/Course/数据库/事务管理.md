# 事务管理

术语事务指的是构成单一的逻辑工作单元的操作的集合。

事务的ACID特性：
- 原子性（Atomicity）：事务是不可分割的工作单元，要么全部执行，要么全部不执行。
- 一致性（Consistency）：事务执行前后，数据库的状态必须保持一致。
- 隔离性（Isolation）：多个事务并发执行时，每个事务的执行不受其他事务的影响。
- 持久性（Durability）：事务一旦提交，其结果对数据库的修改是永久性的，即使系统发生故障，事务的结果也不会丢失。

## 可串行化

在并发执行的条件下，通过保证所执行的任何调度的效果都与没有进行任何并发执行的调度效果一样，来保证数据库的一致性。这种调度被称为可串行化的调度。

这里的调度先只考虑读写操作对变量进行修改所带来的一致性问题。

### 冲突可串行化

考虑调度S中的 属于事务$T_i$和$T_j$的两条连续指令I和J。如果I和J引用相同的数据项，则有下面四种情况

- I = read(Q), J = read(Q) 这种情况下I，J次序无关紧要
- I = read(Q), J = write(Q) 这种情况下顺序是重要的
- I = write(Q), J = read(Q) 同上
- I = write(Q), J = write(Q) 这种情况下I，J次序可能是无关紧要的，但是会影响到下一条read(Q)指令

所以只有两个都是read的情况下，相对顺序才是真正无关紧要的。

定义I和J是冲突的，如果他们由**不同事务**在**相同的数据项**上执行操作，并且其中至少有一条指令是**write操作**。

如果I和J是属于不同事务的指令，并且I和J不冲突，则可以交换I和J的次序来产生一个新的调度S'。此时S和S'是等价的。

如果调度S可以经过一系列非冲突指令的交换而变成调度S'，则称调度S和S'是冲突等价的。

如果一个调度S和一个串行调度是冲突等价的，则称S是**冲突可串行化的。**

### 如何确定一个调度是否是冲突可串行化的

对调度S构造一个有向图，称为优先图。

顶点是事务集，如果二者存在冲突，则产生一条边。也即：

1. 在$T_j$执行read(Q)之前，$T_i$执行write(Q)
2. 在$T_j$执行write(Q)之前，$T_i$执行write(Q)
3. 在$T_j$执行write(Q)之前，$T_i$执行read(Q)

如果优先图中存在一条$T_i\to T_j$的边，则等价于在任何S的串行调度S'中，$T_i$在$T_j$之前执行。

如果关于S的优先图中存在**环**，则调度S是非冲突可串行化的。无环就是冲突可串行化的。

可以借助优先图的偏序关系得到可串行化次序，使用拓扑排序算法即可。

## 事务的隔离性和原子性

可恢复调度要求： 任何事务 $T_i$ 的提交，必须等到它 **读取的所有数据** 已经由**写入**这些数据的事务 $T_j$ 提交。

无级联调度：对于每对$T_i$和$T_j$，如果满足$T_j$读取了先前由$T_i$写的数据项，则$T_i$的提交操作必须出现在$T_j$的这个读操作之前。（否则对于 i 的 abort 可能会级联到j和更多的k）

## 隔离性级别的实现

事务可以只用锁封锁它访问的那些数据项，而不是整个数据库。

可以使用两阶段锁来确保可串行化。

- 在事务的第一个阶段过程中，事务可以获得锁，但不能释放锁。
- 在事务的第二个阶段过程中，事务可以释放锁，但不能获得锁。

其他可能的实现：时间戳，多版本和快照隔离。


## 18章 - 并发控制

为了确保事务的隔离，系统必须对并发事务之间的交互加以控制，这种控制是通过名为并发控制的机制来实现的。本章的讨论忽略了故障。

## 19章 - 恢复系统

恢复系统主要实现ACID中的持久性和原子性。另一个要求是高可用性。（能在出现故障时迅速恢复）

故障有以下三种：

- 事务故障：事务在执行过程中由于某种错误而未能完成，需要回滚。
- 系统故障：系统在运行过程中由于某种错误而出现故障，需要恢复。
- 介质故障：由于硬件故障导致数据丢失。

定义四种操作：read，write，input和output。read和write都针对主存，input和output是在主存和磁盘间搬运数据的操作。

### 恢复与原子性

目标是要么执行事务$T_i$对数据库的所有修改，要么不执行任何修改。

为了达到原子性的目标，需要在修改数据库前，先向**稳定存储器**输出信息，描述要做的修改。这里描述的是使用基于日志的恢复。

更新日志记录描述一次数据库写操作，它具有以下字段：

- 事务标识
- 数据项标识
- 旧值
- 新值

还有一些其他的日志记录，记录重要事件，比如<$T_i$, start>，<$T_i$, commit>，<$T_i$, abort>。

两种操作：撤销操作和重做操作。

- 撤销操作使用一条日志记录，将指定数据项置为旧值。
- 重做操作使用一条日志记录，将指定数据项置为新值。

为了避免级联撤销，回复算法一般要求如果**一个数据项被一个事务修改了，那么在该事务提交或者中止前不允许其他事务修改该数据项。**（使用排他锁）

当一个事务的commit记录被输入到稳定存储器后，我们就说这个事务提交了，此时日志中有足够的信息保证，即使发生系统崩溃，事务所做的更新也可以被重做。如果系统崩溃在commit记录被输入到稳定存储器后，则需要回滚。

- $redo(T_i)$：重做事务$T_i$的更新。但是实际操作会对日志进行依次扫描，并对每条日志记录进行重做。而不是只重做$T_i$的日志记录。
- $undo(T_i)$：撤销事务$T_i$的更新。撤销操作还写日志记录执行的更新。撤销顺序也非常重要！

发生系统崩溃后，系统为了原子性而查阅日志确定哪些事务要重做：

- 如果包含<$T_i$,start>，但是不包含<$T_i$,commit>和<$T_i$,abort>，则**撤销**$T_i$。
- 如果包含<$T_i$,start>和<$T_i$,commit>，或<$T_i$,abort> **要重做$T_i$。** 如果日志包含<$T_i$,abort>，仍要重做的原因是只要存在abort，**也会存在read-only的撤销日志**。这种情况的最终结果是对$T_i$的所有修改进行撤销。是一个冗余，但是可以简化恢复过程。

检查点（checkpoint）：降低恢复开销。

检查点的执行过程如下：

- 将当前位于主存的所有日志记录输出到稳定存储器。
- 将所有修改过的缓冲块输出到磁盘
- 写入一条<checkpoint L>的日志记录。

检查点执行过程中，不允许事务执行任何更新操作。

如果任何事务的commit和abort在checkpoint前，就不需要重做了。

系统发生崩溃后，系统检查日志找到最后一条checkpoint，然后在这个基础上顺序扫描，进行redo和undo。

### 恢复算法

正常操作时的事务回滚：

- 从后往前扫描日志，对每一条<$T_i$,$x_j$,$v_1$,$v_2$>，将$v_1$写入$x$
- 然后往日志里写一条redo-only日志$<T_i,X_j,v_1>$，被称为补偿日志记录

此时对事务所做的每个更新动作（包括恢复成旧值）都在日志里了。

系统崩溃后：

- 在重做阶段，系统通过最后一个checkpoint开始**正向扫描**，重演所有的事务更新。
- 具体的，将待回滚事务的列表undo-list初始化设定为<checkpoint L>日志记录中的列表L。
- 一旦遇到形如$<T_i,X_j,V_1,V_2>$的正常日志记录，或者redo-only的日志记录，就执行重做。
- 一旦发现$<T_i start>$记录，就加入$T_i$到undo-list。
- 发现$<T_i,abort>$或$<T_i,commit>$记录，就从undo-list中移除$T_i$。

在重做阶段末尾，undo-list包含所有尚未完成的事务。

在撤销阶段，系统回滚undo-list中的事务。它从**尾端**开始**反向**扫描日志执行回滚。

- 一旦发现属于undo-list的事务的日志记录，就执行撤销操作。
- 发现undo-list事务的$<T_i,start>$，就往日志里写一条$<T_i,abort>$，然后从undo-list中移除$T_i$。
- 一旦undo-list变为空，撤销阶段就结束了。

组提交：不一定事务提交就直接写日志，而是攒一批事务，然后一起写日志。

### 缓冲区管理



